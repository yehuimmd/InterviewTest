### 2018.1.21面试准备

#### 自我介绍
#### html
- 块级元素和行内元素
- 编写高质量代码
  实现网页结构、样式和行为的分离（精简、重用、有序）
- 尽量不用table标签，代码量大，结构混乱，对搜索引擎不友好
- 尽量少用div，标签语义化，能用p标签的时候尽量用，去样式后代码可读性更好，对兼容终端有利
- 不使用纯样式标签，如b、u、i这类的。
- 前后端分离
 
#### css3
- **transition**属性：设置过度效果，设置几秒后出现什么样式效果。
- **box-sizing**属性：允许你一确切的方式定义适应某个区域的具体内容。假如您需要并排放置两个带边框的框，可通过将 box-sizing 设置为 "border-box"。这可令浏览器呈现出带有指定宽度和高度的框，并把边框和内边距放入框中。**属性值：border-box**。**此元素的内边距和边框不再会增加它的宽度。**
- opacity：设置透明度，ie8以及更早的版本加滤镜属性完成透明度设置filter：alpha（opacity=x）
- **box-shadow**属性：创建阴影效果
- **background-size**属性：设置背景图片的尺寸，
- 属性选择器：基于元素属性的值来相应的元素，从而进行样式设置。（a标签的？号例子）
- 定位属性：
  **相对定位：**是一个比较容易掌握的概念，如果对一个元素进行相对定位，他将会出现在他所在的位置上，可以通过设置垂直和水平位置让这个元素相对于他的起点移动。相对定位实际上可以看成普通流定位模式的一种，因为元素的位置是相当于他在普通流中的位置。

 **绝对定位：**相比于相对定位，绝对定位使元素的位置与文档流无关，因此不占据空间，普通流中的其他元素就像是绝对定位的元素不存在一样。绝对定位的位置是相当于离她最近的那个已经定位的祖先元素确定的。如果没有已 经定位的祖先元素，那么他的位置是相对于初识包含块的。
因为绝对定位与文档流无关，所以他们可以覆盖掉页面上的其他元素，这时，可以通过z-index属性来俩控制这些框的叠放层次。z-index的值越大，框在栈中的位置越高。

 **固定定位：**是绝对定位的一种，差异在于固定元素的包含块是视口。这使我们总是能创建总是出现在窗口中相对位置的浮动元素。
- css reset ：html标签有自己的默认样式，通过csss设置样式**覆盖**掉他的默认样式。不使用*通配符设置样式，因为css很多样式是具有继承权的，但是低，会增加额外的很多代码，破坏css的继承性。
- css命名空间：建议用英文命名，驼峰式命名（驼峰用来区别不同的单词，划线用来实现从属关系）
- 低权重原则：避免滥用子选择器，html 标签的权重为1，class的权重为10，id的权重是100，权重越高，样式越不容易被覆盖，越容易对其他选择符产生影响，为了保证样式容易被覆盖，提高可维护性，css选择符需要保证权重尽可能低。
- **css sprite ：雪碧图**
 一张网页上的图片合并在一张大图上，这样减少http的请求次数，降低服务器端的负担，但是他也降低开发效率和增加了维护的难度。
- 如何设置div居中
  1. 未设置浮动：先设置body text-align：center内容居中，然后用margin设置0 auto自动居中；
  2. 设置了浮动的话，就不能使用自自动居中了，就只能使用margin-left或right实现居中
  3. 设置了position属性的盒子设置自动居中
  left、right都为0px，用margin：0 auto设置自动居中，宽为固定的，高height设置为自动auto，这样就能实现一个盒子的居中了。
 
- css盒模型
  用来存放网页中各类元素
   1.  **宽度属性=左边距+左边框+左填充+内容宽度+右填充+右边框+右边距**
   2.  **高度属性**
   3. 边框属性
   4. 内边距属性（顺时针方向设值）padding
   5. 外边距属性：margin，声明margin，覆盖默认样式（外边距合并）
   6. 盒子计算
   7.  **IE盒子模型**：如果没有申明**!Doctype**文房类型说明，个浏览器按照自己的方式解析盒子，否则按照标准盒子模型来解析
   8.  display属性
        inline，内联元素按；block块级元素
        inline-block：行内元素内的内联元素
        none:隐藏  （不占原有空间）
- 清除浮动的方式
   1. clear（添加空的div）
   2. 父级同时浮动
   3. 父级设置成inline-block
   4. br标签自带的clear属性，设置为both
   5. 给浮动父级元素设置高度
   6. 给父级添加overflow:hidden，加zoom：1出发haslayout
   7. after伪类清除浮动。加zoom：1出发haslayout
 
 #### JavaScript
- 高质量的JavaScript
通过命名空间解决全局变量冲去的问题，命名空间就是一个通过{}对象实现的，在不同的匿名函数中，功能不同，可以生成不同的命名空间。GLOBAL对象。用匿名函数将脚本包起来，可以有效控制全局变量，避免冲突隐患。
- 代码注释的必要性
- JavaScript分层概念
- 变量：可以看做一个盒子用来存储数据数值。
- 数组：存放多个数据的数组变量，数组方法有链接方法cancat、分割方法join、颠倒顺序方法reverse、选择元素方法slice方法、数组排序sort、元素删除splice方法、数组遍历方法forEach、数组映射map、数组过滤filter、数组检索indexOf方法等。
- 函数：被定义一次，执行和调用多次。
- 对象：JavaScript所有事物都是对象：字符串、数组、函数等。
- window对象：
是BOM的核心，window对象指的是当前的浏览器窗口，他表示浏览器的一个实例。
- this对象
 在一般函数的中，this任然指向全局对象，在浏览器里，就是window。在全局函数中，this等于window，而当函数被作为某个对象的方法调用时，this等于那个对象，特别的，匿名函数的执行环境具有全局性，因此其this对象通常指向window。
- js内置对象
  number
  string
  boolean
  date
  array
  math对象
- js的是数据类型
  undefine 
  null
  Boolean
  number
  string
  object
- js的事件
- 移动端得触发事件
-  ajax的缺点
- 浏览器缓存的措施：cookie
- 跨域、跨域原理及解决方案
- 前端缓存及分类
  指的是浏览器缓存，强缓存和协商缓存，
  1. 强缓存：浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如某个css文件，如果浏览器在加载它所在的网页时，这个css文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个css，连请求都不会发送到网页所在服务器；
2. 协商缓存：当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回（304），但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源；若未命中请求，则将资源返回客户端，并更新本地缓存数据（200）。

   强缓存与协商缓存区别：强缓存不发请求到服务器，协商缓存会发请求到服务器。
- 页面加载过程，就是输入URL到加载页面
  1. 输入地址
  2. 浏览器查找域名的 IP 地址
  3. 这一步包括 DNS 具体的查找过程，包括：浏览器缓    存->系统缓存->路由器缓存...
  4. 浏览器向 web 服务器发送一个 HTTP 请求
  5. 服务器的永久重定向响应（从 http://example.com 到 http://www.example.com）
  6. 浏览器跟踪重定向地址
  7. 服务器处理请求
  8. 服务器返回一个 HTTP 响应
  9. 浏览器显示 HTML
  10. 浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）
  11. 浏览器发送异步请求
  （
  - 浏览器分析链接URL
  - 浏览器请求DNS解析域名的IP地址
  - 域名系统解析url的IP地址为多少（浏览器缓    存->系统缓存->路由器缓存...）
  - 浏览器与服务器建立TCP连接
  - 进入HTTP网络
  - 浏览器发出取文件的命令，也就是get、post请求
  - 服务器给出响应
  - 释放TCP连接
  - 浏览器显示带有数据的页面
  ）
- 路由器缓存
每个路由器根据自己所在网络的不同，都会有自己的路由表，在工作时会选择不同的路径，路有缓存是为了发送数据，因为路由器额的最高层一般是网络层，网络层一般是传送数据包，数据包是经过应用层向下传送之后送来的一部分文件数据，如果没有缓存，每次都会查找传送到达方的IP地址就很费力。
- js创建对象的方式
**工厂模式**
将创建对象的代码封装在一个函数中，然后返回一个新创建的对象，直接调用函数，然后传入相应参数实现创建对象新实例。
**构造函数模式**
在构造函数里面使用this对象设置对象属性及方法，通过new创建对象新实例，传入相应参数。
**原型模式**
每创建一个函数都有一个原型对象属性prototype，在构造函数中，通过原型对象属性prototype设置类的属性及方法，通过new创建对象新实例，不用传入相应参数（**共享实例属性**）
**动态原型模式**
构造函数模式+原型对象模式：通过在构造函数内通过this设置对象属性及方法，通过原型对象属性prototype设置对象方法。使用new创建对象新实例，传入相应参数。
**寄生构造模式**
工厂模式，不同之处在于用new创建对象新实例，传入相应参数，而不是直接调用工厂类函数。
**策略模式**


- 作用域：一个语句执行的环境大小，执行环境：定义了变量或函数有权访问的其他数据，决定了他们的行为。每个执行环境都有一个关联的变量对象；每个函数执行都有自己的执行环境，当执行流进入一个函数时，该函数的环境就被推入一个环境栈中。当代码在一个环境中执行时，就会创建变量对象的一个作用域链，作用域链保证了对执行环境有权访问的所以变量和函数都有序的访问。内部环境可以通过查询作用域链访问外部环境，但是外部不能访问内部。（指向变量对象的指针列表）
- 作用域污染问题
- 闭包
指有权访问另一个函数作用域中变量的函数。闭包保存的是整个变量对象。
- 跨域：
1. 图像ping，使用img标签跨域请求数据；
2. jsonp技术：包含在函数调用中的json，（回调函数和数据），JSONP通过script标签，为script标签的src属性一个跨域URL，优点：能够直接访问响应文本，支持在浏览器与服务器间双向通信。
- comet（跨yuan资源共享）：比ajax更高级的技术，向服务器推送数据
- get个post的区别
- TCP与UTP的区别
面向连接和非连接，全双工和半双工，可靠信道和不可靠信道。
**TCP三次握手：**a主动发送请求连接报文，b给出同意连接确认报文，a发送确认连接报文，连接建立；
**TCP四次握手：**a主动发送连接释放请求，b给出确认收到信息，b发送连接释放确认报文，a发送确认释放连接确认，连接释放。
- 怎样优化DOM操作：**文档片段**
  **documentFragment**节点类型：是一种轻量级的文档，可以包含和控制节点，但是不会像完整的文档那样占用额外的资源。文档片段不能直接添加到文档中，但是可以将它作为一个“仓库”来使用，可以在里面存放可以会添加的文档节点。
- **setTimeOut方法**
用于在指定的毫秒数后调用函数或计算表达式。
setTimeout(code,millisec)。第一个参数为需要定时执行的函数事件，第二个参数为定时的时间。用于单次定时执行任务，检测我们的事件发生的时间是否符合我们的定时器要求。而setInterval（）方法也是定时器，不同在于他是多次执行任务，重复性的检测和执行任务。
- cookie和session的区别
cookie缓存在浏览器，session缓存的服务器端。session比较安全。
- 算法和计算机网络
- js面向过程和面向对象的区别
  **面向对象：**就是将你的需求抽象成一个对象然后针对这个对象分析其属性和方法，这个对象我们称之为类，他的一个特点就是封装。
  **面向过程：**是从上往下步步求精，所以面向过程最为重要的是**模块化**的思想方法。是一种以过程为中心的编程思想。就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。
- 模块化编程：
   一个项目都有很多的相似的功能模块，如果每次都需要重新编写模块，那么既费时也耗力，但是引用别人的编码模块的前提是有统一的“打开姿势”。所以js有了一些模块化的规范。
 1. script标签，每个文件都看作一个模块，接口暴露在全局作用域中，用命名空间来组织这些模块的接口。**缺点：**污染全局作用域，开发人员主观的解决模块和代码库的依赖关系。文件只能按照script标签的书写顺序进行加载。大型项目中资源难以管理，代码库混乱。
 2. commonJs规范（用于node后端）：node允许模块通过require方法来异步加载所要依赖的其他模块，通过exports或是module.exports来导出需要暴露的接口。
 3. module.exports和exports的区别：
 exports是module.exports的辅助方法，你的模块最终返回module.exports给调用者，而不是exports。exports所做的事情是收集属性。如果module.exports当前没有任何属性的话，exports会把这些属性赋予module.exports，如果module.exports有属性的话，exports中所有的东西将会被忽略。
 exports是指向module.exports的引用；
 module.exports初始值为一个空对象{}，所有exports的初始值也是一个{ }；
 require()返回的是module.exports，而不是exports。
 4. AMD规范（异步模块定义），用于node前端部分，是commonJS的一个延伸，定义了两种API：
 require([module], callback); //加载一系列模块  
define(id, [depends], callback);//定义并暴露模块。
AMD对于依赖的模块，提前执行依赖前置。 
5. CMD规范：和AMD相比，他在依赖引入部分动态加入，通过传参的形式进行。
CMD对于依赖的模块延迟执行。依赖就近，就是要用到那个模块的时候我们在进行require()。
6. ES6模块化：主要是import和exports，import用于引入模块，exports用于导出模块。
- 纯函数：
一个函数的输出不受外部环境影响，同时也不影响外部环境时，只与输入的数据有关。相同的输入就有相同事物输出。该函数就是纯函数。
- Linux命令（未学）
- JavaScript设计模式：
**构造函数：**一个函数，出于创建对象的目的定义的。（new操作符和对象字面量var 
person = { name：‘yehui’ ，age：20}）。
**工厂模式、建造者模式、策略模式**

**策略模式：**
定义：策略模式就是定义一系列的算法，把他们一个个封装起来，并且使他们可以相互替换。如：**表单验证**
避免多重条件选择语句（if）。
复用性高。用来封装算法。业务封装。

- js基础
- 计算机网络
-  性能优化
-  开发技巧
- 移动端知识
- 安全性问题
#### Node
- node的服务器事件驱动
**事件驱动的大体过程：**
1. 你用浏览器访问nodejs服务器上的"/about.html"
2. nodejs服务器接收到你的请求，调用一个函数从磁盘上读取这个文件。
3. 这段时间，nodejs webserver在服务后续的web请求。
4. 当文件读取完毕，有一个回调函数被插入到nodejs的服务队列中。
5. nodejs webserver运行这个函数，实际上就是渲染（render）了about.html页面返回给你的浏览器。

   **长轮询：**客户端始终发一个请求到服务器端，服务器端有内容则立即返回，没有内容则保持连接 不返回结果，等到有内容时再返回结果，客户端得到结果后再发请求。 这样客户端与服务器端就一直保持着一个连接。
事件驱动机制是Node.js通过内部**单线程**高效率地维护**事件循环队列**来实现的，没有多线程的资源占用和上下文切换，这**意味着面对大规模的http请求，Node.js凭借事件驱动搞定一切。**
- 函数式编程思想
以函数为主要载体的编程方式。
可复用性好，可维护性更好，作用域局限，副作用少。高阶函数（参数和返回值可以是函数的函数）、链式的回调函数、**闭包**（可以保留局部变量不被释放的代码块），**用途：**持久化变量（缓存器）、映射map。
**函数式编程的特点：**
1. 函数是主要载体；
2. 只用“表达式，不用语句”；
3. 没有副作用：指函数与内部外部进行互动时，不产生其他行为，处理返回一个新的值。尤其不能修改外部变量的值。
4. 不修改状态：
5. 引用透明：指函数的运行不依赖于外部变量或状态，只与传入的参数有关。
6. 易于代码管理、**并发编程**、代码简洁，开发快速、易于理解
- 数据单向绑定
指我们先把模板写好，然后把模板个数据整合在一起形成html，然后插入到文档流中。
**双向数据绑定：**指单向数据绑定+UI事件监听（即模型加视图的绑定，无论数据改变或者是用户操作，都带来相互的变动，自动更新。）

- **事件循环机制**
所谓事件循环是指node.js会把所有的异步操作使用事件机制解决，有个线程在不断地循环检测事件队列。

 node.js中所有的逻辑都是事件的回调函数，所以node.js始终在事件循环中，程序入口就是事件循环第一个事件的回调函数。事件的回调函数中可能会发出I/O请求或直接发射（ emit）事件，执行完毕后返回事件循环。事件循环会检查事件队列中有没有未处理的事件，直到程序结束。node.js的事件循环对开发者不可见，由libev库实现，libev不断检查是否有活动的、可供检测的事件监听器，直到检查不到时才退出事件循环，程序结束。
#### es6
- rest参数：用于获取函数的多余参数，**...变量名**。，rest参数后不能有其他参数了。
- 扩展运算符：**...**就是三个点。他好比rest参数的逆运算，将一个数组转换为逗号分隔的参数序列。可用于合并数组。
- promise对象
  用来传递异步信息，解决回调地域的问题。
  1. 有三种状态：pending（进行中）、resolve（已完成）、reject（已失败）。
  2. 用法：创建promise对象；实例生成后，可用then方法分别指定resolve和reject的回调函数；resolve和reject的回调函数方法的参数都可以为promise对象。
  3. promise.all()方法，用于包装对个promise对象；promise.race()方法也是。
- ES6的异步操作
- yield语句
是generator函数的暂停标志。

 **next方法的运行逻辑：**
1. 遇到yield语句就暂停执行后面的操作，并将紧跟在**yield后面表达式的值**作为返回的对象的value属性值。
2. 下次调用next方法时再继续往下执行，直到遇到下一个yield语句；
3. 如果没有遇到新的yield语句，就一直运行到函数结束，直到遇到return语句为止，并将return语句后面的表达式的值作为返回对象的value属性值；
4. 如果该函数没有return语句，则返回对象的value属性值为undefined
注意： yield语句为javascript提供了手动的 “惰性求值”。
yield语句与return语句有相似之处也有区别，相似之处在于都返回紧跟在后面的值，区别在于return语句不具备记忆功能。
- yield* 语句
1. yield*语句，专门用来在一个generator函数里面执行另一个generator函数
2. 如果yield命令后面没有星号，将返回一个遍历器对象，加上星号后将会返回遍历对象的具体值。yield* 语句相当于在generator函数内部部署了一个for...of循环。
3. 如果generator函数有return语句，那么将会返回相应的数据，如果return()不带任何参数，则相应位置返回的值为undefined。
4. yield* 命令可以很方便的取出嵌套数组的所有成员。

#### ReactJs
- reactJs的相关知识点
- 组件的生命周期

#### 简历上的测试框架了解
- 基金会
#### 算法（数据结构书）
- 排序方法
1. 直接排序：比较出有序数列。
2. 希尔排序：基本思想就是将整个待排序的记录分成若干个子序列进行直接排序，然后在对全部的子序列进行直接排序。（d = 5, 隔五个数选一个成为一组，即两个数为一组，然后进行组内直接排序，得到第一趟排序的数列，写下相应位置上的数）
3. 快速排序：
**冒泡排序：**无序在前，有序在后，选一个初始关键字，然后依次查找，大于关键字的则移动到关键字的后面。
**快速排序：**是对冒泡排序的改进，基本思想是通过一趟排序将待排序的记录分割成两个独立的部分，其中一部分的记录关键字均比邻一部分的关键字小，然后对这两部分记录进行排序。**设置low和hight，直到low和hight相等为止。**快速排序的过程递归进行。

- 二叉树结构